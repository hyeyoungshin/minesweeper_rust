---
14:34:50 Mountain

# Moved data vs Copied data

---

## Moved data vs Copied data in Rust
> **[Hyeyoung]:** in rust, data is sometimes moved or copied. when is appropriate to "move" data and when is appropriate to "copy" data? And what's the difference between copying data and cloning data?


> **[AI]:** This is fundamental to understanding Rust's ownership system. (Continues...)

### Move vs Copy
**Move (default for most types)**  
When you move data, ownership transfers and the original variable becomes invalid:
```rust
let s1 = String::from("hello");
let s2 = s1;  // s1 is MOVED to s2

// println!("{}", s1);  // ERROR! s1 is no longer valid
println!("{}", s2);     // OK
```

 **Copy (for simple types)**  
When you copy data, both variables remain valid because the data is duplicated on the stack:
```rust
 let x = 5;
 let y = x;  // x is COPIED to y

 println!("{}", x);  // OK! x is still valid
 println!("{}", y);  // OK! y has its own copy
```

 **When does Copy happen?**  
A type can be Copy only if:  
1. It's stored entirely on the stack (no heap allocation)
2. All its fields are also Copy
3. It implements the Copy trait  
 
**Types that are Copy:**  
- All integers: i32, u64, etc.  
- Floats: f32, f64  
- Booleans: bool  
- Characters: char  
- Tuples of Copy types: (i32, i32)  
- Arrays of Copy types: [i32; 5]  

 **Types that are NOT Copy (they Move):**
- String (has heap data)  
- Vec<T> (has heap data)  
- HashMap (has heap data)  
- Any type with heap-allocated data  
- Any type that implements Drop  

## Copy vs Clone
 **Copy** 
- Implicit and cheap (bitwise copy)
- Happens automatically in assignments
- Only for simple stack-only types
- Cannot be customized
 ```rust
 let x = 5;
 let y = x;  // Automatic copy, no explicit call needed
 ```
**Clone**  
 Explicit and potentially expensive
- Must call .clone() manually
- Can perform deep copying (including heap data)
- Can be customized via Clone trait
 ```rust
 let s1 = String::from("hello");
 let s2 = s1.clone();  // Explicit clone, copies heap data

 println!("{}", s1);  // OK! s1 still valid
 println!("{}", s2);  // OK! s2 has its own copy
```

## Making Your Own Types Copy or Clone
```rust
// Derive Copy (only if all fields are Copy)
#[derive(Copy, Clone)]  // Copy requires Clone
struct Point {
    x: i32,
    y: i32,
}

// Derive Clone (works for any type)
#[derive(Clone)]
struct Person {
    name: String,  // String is not Copy
    age: i32,
}

let p1 = Point { x: 1, y: 2 };
let p2 = p1;  // Automatic copy
println!("{}, {}", p1.x, p2.x);  // Both valid

let person1 = Person { name: "Alice".to_string(), age: 30 };
let person2 = person1.clone();  // Explicit clone
println!("{}, {}", person1.name, person2.name);  // Both valid
``` 
### When to use what?
Use Move (default):

When you want clear ownership transfer  
For types with heap data  
When you don't need the original value anymore  

Use Copy:

For small, stack-only types  
When implicit copying makes sense  
When the type is cheap to duplicate  

Use Clone:

When you need a deep copy of heap-allocated data  
When Move semantics would be inconvenient  
When you need both the original and a copy  

### Performance Considerations
```rust
// Cheap - Copy
let x = 5;
let y = x;  // Just copies 4 bytes

// Free - Move
let v1 = vec![1, 2, 3];
let v2 = v1;  // Just moves the pointer, doesn't copy data

// Expensive - Clone
let v1 = vec![1, 2, 3];
let v2 = v1.clone();  // Allocates new heap memory and copies all elements
```

### Rule of thumb:

Move is the default - no cost, clear ownership  
Copy is for tiny stack types - automatic and cheap  
Clone is for when you really need a duplicate - explicit and potentially expensive  

Think: "Can I avoid cloning?" â†’ Use moves and references instead when possible!